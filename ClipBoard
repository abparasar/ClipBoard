import torch
from transformers import BertTokenizer, BertForSequenceClassification
from torch.nn.functional import softmax
from torch.utils.data import DataLoader, Dataset

# Sample dataset class
class IntentDataset(Dataset):
    def __init__(self, texts, labels, tokenizer, max_length):
        self.texts = texts
        self.labels = labels
        self.tokenizer = tokenizer
        self.max_length = max_length

    def __len__(self):
        return len(self.texts)

    def __getitem__(self, idx):
        text = self.texts[idx]
        label = self.labels[idx]
        encoding = self.tokenizer.encode_plus(
            text,
            add_special_tokens=True,
            max_length=self.max_length,
            return_token_type_ids=False,
            padding='max_length',
            truncation=True,
            return_attention_mask=True,
            return_tensors='pt',
        )
        return {
            'input_ids': encoding['input_ids'].flatten(),
            'attention_mask': encoding['attention_mask'].flatten(),
            'labels': torch.tensor(label, dtype=torch.long)
        }

# Load the pre-trained BERT model and tokenizer
model_name = 'bert-base-uncased'  # or 'distilbert-base-uncased'
tokenizer = BertTokenizer.from_pretrained(model_name)
model = BertForSequenceClassification.from_pretrained(model_name, num_labels=100)  # Replace 100 with the actual number of intents

# Move the model to GPU if available
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model.to(device)

# Sample input data
texts = [
    "What's the status of my account?",
    "I'd like to open a new savings account.",
    "How can I transfer funds?",
    "What are the interest rates for loans?"
]
labels = [0, 1, 2, 3]  # Example labels corresponding to intents

# Create DataLoader
max_length = 32  # Adjust based on your needs
dataset = IntentDataset(texts, labels, tokenizer, max_length)
dataloader = DataLoader(dataset, batch_size=2)  # Adjust batch size as needed

# Set the model to evaluation mode
model.eval()

# Set the threshold for intent selection
threshold = 0.98

predicted_intents = []

with torch.no_grad():
    for batch in dataloader:
        input_ids = batch['input_ids'].to(device)
        attention_mask = batch['attention_mask'].to(device)

        # Get model predictions
        outputs = model(input_ids, attention_mask=attention_mask)
        logits = outputs.logits

        # Apply softmax to get probabilities
        probabilities = softmax(logits, dim=1)

        # Get the predicted intent and its probability
        for i in range(probabilities.shape[0]):
            max_prob, max_idx = torch.max(probabilities[i], dim=0)
            if max_prob >= threshold:
                predicted_intents.append((max_idx.item(), max_prob.item()))
            else:
                predicted_intents.append((None, None))  # No intent if below threshold

# Output the predicted intents
for text, (intent, prob) in zip(texts, predicted_intents):
    if intent is not None:
        print(f"Text: '{text}' - Predicted Intent: {intent}, Probability: {prob:.2f}")
    else:
        print(f"Text: '{text}' - No intent predicted (probability below threshold)")